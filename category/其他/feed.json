{
    "version": "https://jsonfeed.org/version/1",
    "title": "严于律己 宽以待人 • All posts by \"其他\" category",
    "description": "",
    "home_page_url": "https://wmingchong.github.io",
    "items": [
        {
            "id": "https://wmingchong.github.io/2023/02/13/qita/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/",
            "url": "https://wmingchong.github.io/2023/02/13/qita/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/",
            "title": "Lambda架构",
            "date_published": "2023-02-13T02:08:12.000Z",
            "content_html": "<h2 id=\"lambda架构\"><a class=\"markdownIt-Anchor\" href=\"#lambda架构\">#</a> lambda 架构</h2>\n<ul>\n<li>离线计算和实时计算提供服务的问题</li>\n<li>离线计算的有缺点：\n<ul>\n<li>优点：能够处理的数据量可以很大，比如 pb 级别</li>\n<li>缺点：速度比较慢，分钟级别的延迟</li>\n</ul>\n</li>\n<li>实时计算\n<ul>\n<li>优点：响应快，来一条数据处理一条， ms 级别的响应</li>\n<li>缺点：处理的数据量小</li>\n</ul>\n</li>\n<li>离线计算框架\n<ul>\n<li>hadoop</li>\n<li>spark core， spark SQL</li>\n<li>hive</li>\n</ul>\n</li>\n<li>实时计算框架\n<ul>\n<li>spark streaming</li>\n<li>storm</li>\n<li>flink</li>\n</ul>\n</li>\n<li>消息中间价\n<ul>\n<li>flume 日志采集系统</li>\n<li>kafka 消息队列</li>\n</ul>\n</li>\n<li>存储相关\n<ul>\n<li>hbase nosql 数据库</li>\n<li>hive sql 操作 hdfs 数据</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"推荐算法架构\"><a class=\"markdownIt-Anchor\" href=\"#推荐算法架构\">#</a> 推荐算法架构</h2>\n<ul>\n<li>找回 ——》排序 ——》策略调整</li>\n</ul>\n<h3 id=\"推荐系统构建模型\"><a class=\"markdownIt-Anchor\" href=\"#推荐系统构建模型\">#</a> 推荐系统构建模型</h3>\n<ul>\n<li>数据收集\n<ul>\n<li>显性评分</li>\n<li>隐性评分</li>\n</ul>\n</li>\n<li>特征工程\n<ul>\n<li>协同过滤：用户 - 物品矩阵</li>\n<li>基于内容：分词 tf-idf word2Vec</li>\n</ul>\n</li>\n<li>模型训练\n<ul>\n<li>协同过滤\n<ul>\n<li>kNN</li>\n<li>矩阵分解</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>评估、模型上线</li>\n</ul>\n<h3 id=\"协同过滤思路介绍\"><a class=\"markdownIt-Anchor\" href=\"#协同过滤思路介绍\">#</a> 协同过滤思路介绍</h3>\n<ul>\n<li>CF 物以类聚，人以群分</li>\n<li>做系统过滤的话，首先特征工程把 用户 - 物品的评分矩阵创建出来</li>\n<li>基于用户的协同过滤\n<ul>\n<li>给用户 A 找到最相似的 N 个用户</li>\n<li>N 个用户消费过哪些物品</li>\n<li>N 个用户消费过的物品中减去 A 用户消费过的就是推荐结果</li>\n</ul>\n</li>\n<li>基于物品的协同过滤\n<ul>\n<li>给物品 A 找到最相似的 N 个物品</li>\n<li>A 用户消费记录 找到这些物品的相似物品</li>\n<li>从这些相似物品先去重减去 A 用户消费过的就是推荐结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"相似度计算\"><a class=\"markdownIt-Anchor\" href=\"#相似度计算\">#</a> 相似度计算</h3>\n<ul>\n<li>余弦相似度、皮尔逊相关系数\n<ul>\n<li>向量的夹角余弦值</li>\n<li>皮尔逊会对向量的每一个分量做中心化</li>\n<li>余弦只考虑方向 不考虑向量长度</li>\n<li>如果评分数据是连续的数值比较适合中余弦，皮尔逊算相似度</li>\n</ul>\n</li>\n<li>杰卡德相似度\n<ul>\n<li>交集 / 并集</li>\n<li>计算评分是 0 1 布尔值的相似度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于模型的算法\"><a class=\"markdownIt-Anchor\" href=\"#基于模型的算法\">#</a> 基于模型的算法</h3>\n<ul>\n<li>用户矩阵比较稀疏的时候 ，直接去取物品的向量 用户向量计算相似度不太合适</li>\n<li>基于，模型的方法可以解决用户矩阵 物品矩阵比较稀疏的问题</li>\n<li>矩阵分解：\n<ul>\n<li>把大的矩阵分解成两个比较小的 用户矩阵 物品矩阵</li>\n<li>大矩阵约等于 用户矩阵 乘 物品矩阵</li>\n<li>使用 als 交替最小二乘法优化损失</li>\n<li>优化之后的用户矩阵 取出用户向量</li>\n<li>优化之后的物品矩阵 取出物品向量</li>\n<li>用户向量点乘物品向量 得到最终的评分预测</li>\n</ul>\n</li>\n<li>EE\n<ul>\n<li>Exploitation &amp; Explortation 探索与利用问题</li>\n<li>Exploition 利用用户的历史行为 只给他看曾经看过的 / 消费过的</li>\n<li>Explortation （探测 搜索）发现用户的新兴趣</li>\n<li>ee 问题实际上是矛盾的</li>\n</ul>\n</li>\n<li>评估手段\n<ul>\n<li>离线评估和在线评估结合，定期做问卷调查\n<ul>\n<li>在线评估：灰度发布 &amp; A/B 测试</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"推荐系统的冷启动\"><a class=\"markdownIt-Anchor\" href=\"#推荐系统的冷启动\">#</a> 推荐系统的冷启动</h3>\n<ul>\n<li>用户冷启动\n<ul>\n<li>尽可能收集用户信息 构建用户画像（打标签</li>\n<li>根据用户的标签可以做人群类聚 用户已有的用户的行为做推荐</li>\n<li>更多的使用流行度对剑</li>\n</ul>\n</li>\n<li>物品冷启动\n<ul>\n<li>物品打标签 构建物品画像</li>\n<li>基于内容的推荐</li>\n</ul>\n</li>\n<li>系统冷启动\n<ul>\n<li>如果应用缺少用户行为数据 -》基于内容的推荐</li>\n<li>随着用户行为积累的越来越多 -》协同过滤</li>\n<li>基于内容和协同过滤共同工作</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于内容的推荐\"><a class=\"markdownIt-Anchor\" href=\"#基于内容的推荐\">#</a> 基于内容的推荐</h3>\n<ul>\n<li>\n<p>给物品打标签</p>\n<ul>\n<li>系统自己提取从业务数据库中提取</li>\n<li>用户填写</li>\n<li>中文分词 利用算法计算词的权重</li>\n</ul>\n</li>\n<li>\n<p>利用标签的文字 转换成词向量</p>\n<ul>\n<li>word2Vec 词 -》向量</li>\n<li>用向量来表示语义</li>\n<li>如果两个词的词向量相似度比较高 认为这两个词的语义相近</li>\n</ul>\n</li>\n<li>\n<p>利用词向量 构建物品的向量</p>\n<ul>\n<li>一个物品有 N 个关键词，一个关键词对应一个语义</li>\n<li>求和（权重 * 词向量）/N</li>\n<li>利用 N 个关键词的词向量获取物品的向量</li>\n</ul>\n</li>\n<li>\n<p>通过物品计算相似度</p>\n<ul>\n<li>皮尔逊 相关系数 计算物品向量的相似度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于内容的推荐-2\"><a class=\"markdownIt-Anchor\" href=\"#基于内容的推荐-2\">#</a> 基于内容的推荐</h3>\n<ul>\n<li>content_based: 词向量 ——》物品向量 ——》计算相似度</li>\n<li>item_based cf：user_item matrix——》物品向量 ——》相似度</li>\n<li>区别\n<ul>\n<li>物品向量构建过程有区别</li>\n<li>基于内容的推荐\n<ul>\n<li>物品向量 文本（物品描述信息， 系统填标签，用户填标签）</li>\n</ul>\n</li>\n<li>基于物品的推荐\n<ul>\n<li>用户对物品的评分矩阵 用户的行为数据中来</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"baseline基准预测\"><a class=\"markdownIt-Anchor\" href=\"#baseline基准预测\">#</a> Baseline：基准预测</h3>\n<ul>\n<li>所有物品的评分平均值</li>\n<li>找到每一个用户对物品的平均评分的 bias bu</li>\n<li>找到每一个物品对平均评分 bias bi</li>\n<li>预测的得分 mean+bu+bi u 代表第 u 个用户 i 代表第 i 个物品</li>\n<li>可以使用梯度下降来优化损失</li>\n</ul>\n<h3 id=\"矩阵分解\"><a class=\"markdownIt-Anchor\" href=\"#矩阵分解\">#</a> 矩阵分解</h3>\n<ul>\n<li>SVD 奇异值分解\n<ul>\n<li>一个大矩阵 分成 3 个小矩阵 中间是一个 k 方阵</li>\n<li>SVD 只适用于没有缺失值 必须是稠密矩阵</li>\n</ul>\n</li>\n<li>Funk SVD\n<ul>\n<li>一个大的矩阵分成两个小矩阵</li>\n<li>LFM 原理</li>\n</ul>\n</li>\n<li>BiasSVD 矩阵分解 + baseline</li>\n<li>SVD++ 矩阵分解 + baseline + 其他影响（点击、收藏、购买）</li>\n</ul>\n<h3 id=\"基于内容的推荐-3\"><a class=\"markdownIt-Anchor\" href=\"#基于内容的推荐-3\">#</a> 基于内容的推荐</h3>\n<ul>\n<li>画像构建给用户、物品打标签\n<ul>\n<li>物品画像\n<ul>\n<li>分类信息</li>\n<li>标题</li>\n<li>电影、音乐、主演。。</li>\n</ul>\n</li>\n<li>用户画像\n<ul>\n<li>喜好的物品类别、行为偏好</li>\n<li>基本人口学属性</li>\n<li>活跃程度</li>\n<li>风控维度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>PGC 应用自己生成</li>\n<li>UGC 用户生成</li>\n<li>基于内容推荐的算法流程\n<ul>\n<li>用户画像、物品画像</li>\n<li>匹配用户画像、物品画像</li>\n</ul>\n</li>\n<li>物品冷启动问题\n<ul>\n<li>画像 -&gt; 词向量 -&gt; 物品向量 -&gt; 计算物品相似度</li>\n<li>从文本描述的角度找相似的物品</li>\n<li>当用户在浏览 A 的时候，通过上述套路找到跟物品 A 相似的一系列物品</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "推荐系统"
            ]
        },
        {
            "id": "https://wmingchong.github.io/2023/02/12/qita/SQL%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%87%BD%E6%95%B0/",
            "url": "https://wmingchong.github.io/2023/02/12/qita/SQL%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%87%BD%E6%95%B0/",
            "title": "SQL关键字和函数",
            "date_published": "2023-02-12T01:08:12.000Z",
            "content_html": "<h3 id=\"sql关键字以及函数\"><a class=\"markdownIt-Anchor\" href=\"#sql关键字以及函数\">#</a> SQL 关键字以及函数</h3>\n<h4 id=\"sql中的开窗口函数over\"><a class=\"markdownIt-Anchor\" href=\"#sql中的开窗口函数over\">#</a> SQL 中的开窗口函数 OVER ()</h4>\n<p><strong>定义</strong>：OVER 用于为行定义一个窗口，它对一组值进行操作，不需要使用 GROUP BY 子句对数据进行分组，能够在同一行中同时返回基础行的列和聚合列。</p>\n<blockquote>\n<p><strong>语法</strong>：OVER ([ PARTITION BY column] [ ORDER BY culumn ] )</p>\n</blockquote>\n<p><strong>用法</strong>：OVER 开窗函数必须与聚合函数或排序函数一起使用，聚合函数一般指 SUM (),MAX (),MIN,COUNT (),AVG () 等常见函数。排序函数一般指 RANK (),ROW_NUMBER (),DENSE_RANK (),NTILE () 等。</p>\n<blockquote>\n<p><strong>拓展</strong>：PARTITION BY 子句进行分组；ORDER BY 子句进行排序。</p>\n</blockquote>\n<h4 id=\"sql中的窗口函数\"><a class=\"markdownIt-Anchor\" href=\"#sql中的窗口函数\">#</a> SQL 中的窗口函数</h4>\n<blockquote>\n<p>first_value： 用来返回一个分组窗口里的第一行记录，也即排名第一的那行记录。</p>\n</blockquote>\n<blockquote>\n<p>last_value： 和 first_value 相反，用来返回分组窗口里的最后一行记录，也即倒数第一的那行记录。</p>\n</blockquote>\n<blockquote>\n<p>nth_value： 用来返回分组内指定行的记录。</p>\n</blockquote>\n<blockquote>\n<p>ntile： 用来在分组内继续二次分组。</p>\n</blockquote>\n<blockquote>\n<p>ROW_NUMBER ()：当前行在其分组内的序号。不管其排序结果中是否出现重复值。其排序结果都为：1,2.3.4.5.。顺序排序 ——1、2、3</p>\n</blockquote>\n<blockquote>\n<p>DENSE_RANK ()：不间断的组内排序。使用这个函数时，可以出现 1.1.2.2 这种形式的分组。并列排序，不跳过重复序号 ——1、1、2</p>\n</blockquote>\n<blockquote>\n<p>RANK ()：间断的组内排序。其排序结果可能出现如下结果：1.1.3.4.4.6。并列排序，跳过重复序号 ——1、1、3</p>\n</blockquote>\n<h4 id=\"sql中的日期函数date_add\"><a class=\"markdownIt-Anchor\" href=\"#sql中的日期函数date_add\">#</a> SQL 中的日期函数 DATE_ADD ()</h4>\n<p>date_add ()：常常用户在 mysql 的 sql 中实现对日期类型的操作，比如增加或者减少，但是不改变原来的数据，只是对查询的数据做处理</p>\n<blockquote>\n<p>语法：DATE_ADD (date,INTERVAL expr unit)</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 得到当前时间增加1天的结果</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> date_add(now(),<span class=\"type\">interval</span> <span class=\"number\">1</span> <span class=\"keyword\">day</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 得到当前时间减少72个小时的结果</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> date_add(now(),<span class=\"type\">interval</span> <span class=\"number\">-72</span> <span class=\"keyword\">hour</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"sql中的union\"><a class=\"markdownIt-Anchor\" href=\"#sql中的union\">#</a> SQL 中的 union</h4>\n<p>作用：将两张毫不相干的表的查询结果拼接在一起输出，前提是两个查询的列数要相同。</p>\n<h4 id=\"sql中的round\"><a class=\"markdownIt-Anchor\" href=\"#sql中的round\">#</a> SQL 中的 ROUND ()</h4>\n<p>round () 函数用于把<strong>数值字段</strong>舍入为指定的小数位数</p>\n<blockquote>\n<p>语法：SELECT ROUND (column_name,decimals) FROM [表名]</p>\n<p>column_name: 要舍入的字段，必需</p>\n<p>decimals: 规定要返回的小数位数，可选</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- ROUND(X)函数将值X四舍五入之后保留整数部分</span></span><br><span class=\"line\"><span class=\"comment\">-- -7</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">-6.6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 1100</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1123.26723</span>,<span class=\"number\">-2</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 1000</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">1123.26723</span>,<span class=\"number\">-3</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 根据参数D值，将参数X四舍五入后得到保留小数点后D位的值，X值的小数位不够D位的补零</span></span><br><span class=\"line\"><span class=\"comment\">-- 如果D为负值，则保留小数点左边D位，先进行四舍五入操作，再将相应的位数值取零</span></span><br><span class=\"line\"><span class=\"comment\">-- -6.7</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ROUND(<span class=\"number\">-6.66</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"sql中的日期格式化函数date_format\"><a class=\"markdownIt-Anchor\" href=\"#sql中的日期格式化函数date_format\">#</a> SQL 中的日期格式化函数 date_format ()</h4>\n<p>date_format 函数用于格式化日期字段。</p>\n<blockquote>\n<p>语法：DATE_FORMAT (date, format)</p>\n<p>date 为日期字段，format 为格式化字符串。常用的格式化字符有 % Y、% m、% d 等</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 这将返回日期字段按照“年-月-日”格式格式化后的结果。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DATE_FORMAT(date_field, <span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 需要注意的是，在使用 date_format 函数时，date 字段需要是日期类型的，如果是字符串类型的日期需要使用str_to_date函数转换成日期类型。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> DATE_FORMAT(str_to_date(<span class=\"string\">&#x27;2022-10-01&#x27;</span>,<span class=\"string\">&#x27;%Y-%m-%d&#x27;</span>),<span class=\"string\">&#x27;%Y-%m-%d %T&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">-- 这将返回字符串类型 &#x27;2022-10-01&#x27; 转换成日期类型后的结果，并按照 &#x27;%Y-%m-%d %T&#x27;格式输出。</span></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "SQL"
            ]
        }
    ]
}